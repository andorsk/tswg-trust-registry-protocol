// Package trqp provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package trqp

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for RegistryTypePeerType.
const (
	Metaregistry RegistryTypePeerType = "metaregistry"
	Peer         RegistryTypePeerType = "peer"
	Subordinate  RegistryTypePeerType = "subordinate"
	Superior     RegistryTypePeerType = "superior"
)

// Defines values for StatusTypeStatus.
const (
	Current    StatusTypeStatus = "current"
	Expired    StatusTypeStatus = "expired"
	Revoked    StatusTypeStatus = "revoked"
	Terminated StatusTypeStatus = "terminated"
)

// AssuranceLevelListType defines model for AssuranceLevelListType.
type AssuranceLevelListType = []AssuranceLevelType

// AssuranceLevelType Creates assurance level as a top-level/first-class-citizen of a Trust Registry. AssuranceLevel values
// MUST be defined in an EGF if they are used.
type AssuranceLevelType struct {
	Description string `json:"description"`
	Identifier  string `json:"identifier"`
	Name        string `json:"name"`
}

// AuthorizationListType defines model for AuthorizationListType.
type AuthorizationListType = []AuthorizationType

// AuthorizationResponseListType defines model for AuthorizationResponseListType.
type AuthorizationResponseListType = []AuthorizationResponseType

// AuthorizationResponseType defines model for AuthorizationResponseType.
type AuthorizationResponseType struct {
	// AssuranceLevel The Assurance Level for the Authorization. Defined in the EGF. [OPTIONAL]
	AssuranceLevel *AssuranceLevelType `json:"assuranceLevel,omitempty"`

	// AuthorizationID the VID that identifies the particular Authorization.
	AuthorizationID *string `json:"authorizationID,omitempty"`

	// AuthorizationStatus Status and textual description for Entity Registration Status, and Entity Authorization Status
	AuthorizationStatus *StatusType `json:"authorizationStatus,omitempty"`

	// AuthorizationUniqueString The unique string that identifies the Authorization.
	AuthorizationUniqueString string `json:"authorizationUniqueString"`

	// AuthorizationValidity The Validity dates related to this particular authorization.
	AuthorizationValidity *ValidityDatesType `json:"authorizationValidity,omitempty"`
	Description           string             `json:"description"`

	// EntityID The VID that identifies the Entity that may (i.e. it may be expired, revoked, terminated)  hold the particular Authorization.
	EntityID string `json:"entityID"`
}

// AuthorizationType defines model for AuthorizationType.
type AuthorizationType struct {
	// AssuranceLevel The Assurance Level for the Authorization. Defined in the EGF. [OPTIONAL]
	AssuranceLevel *AssuranceLevelType `json:"assuranceLevel,omitempty"`
	Description    string              `json:"description"`
	Identifier     string              `json:"identifier"`
	Simplename     string              `json:"simplename"`
}

// EntityListType defines model for EntityListType.
type EntityListType = []EntityType

// EntityType defines model for EntityType.
type EntityType struct {
	Authorizations *AuthorizationListType `json:"authorizations,omitempty"`

	// EntityDataValidity Date and Time of validity.
	EntityDataValidity *ValidityDatesType `json:"entityDataValidity,omitempty"`

	// EntityVID The primary identifier for the Entity (i.e. the primary key)
	EntityVID              *string            `json:"entityVID,omitempty"`
	GovernanceFrameworkVID string             `json:"governanceFrameworkVID"`
	ParticipatingNamepaces *NamespaceListType `json:"participatingNamepaces,omitempty"`

	// PrimaryTrustRegistryVID A VID identifying the registered entity's Primary Trust Registry
	PrimaryTrustRegistryVID *string `json:"primaryTrustRegistryVID,omitempty"`

	// RegistrationStatus Status and textual description for Entity Registration Status, and Entity Authorization Status
	RegistrationStatus       *StatusType `json:"registrationStatus,omitempty"`
	SecondaryTrustRegistries *[]string   `json:"secondaryTrustRegistries,omitempty"`
}

// ExportFile defines model for ExportFile.
type ExportFile struct {
	Entities *EntityListType `json:"entities,omitempty"`

	// Extractdatetime The time of the data extraction.
	Extractdatetime time.Time      `json:"extractdatetime"`
	Lookups         *ExportLookups `json:"lookups,omitempty"`

	// Registries Array of RegistryQueryType
	Registries *RegistryListType `json:"registries,omitempty"`

	// Resources Array of RegistryQueryType
	Resources *RegistryListType `json:"resources,omitempty"`

	// Validity Date and Time of validity.
	Validity *ValidityDatesType `json:"validity,omitempty"`

	// Version Version string [OPTIONAL]
	Version *string `json:"version,omitempty"`
}

// ExportLookups defines model for ExportLookups.
type ExportLookups struct {
	AssuranceLevels *AssuranceLevelListType `json:"AssuranceLevels,omitempty"`
	Authorizations  *AuthorizationListType  `json:"Authorizations,omitempty"`
	Namespaces      *NamespaceListType      `json:"Namespaces,omitempty"`
	VIDMethods      *VIDMethodListType      `json:"VIDMethods,omitempty"`
}

// IntegrityType Integrity object
type IntegrityType struct {
	// Hash the hash of the data.
	Hash string `json:"hash"`

	// Hashtype Hashing algorithm well-known-name. TODO: Reference to some list?
	Hashtype string `json:"hashtype"`
}

// NamespaceListType defines model for NamespaceListType.
type NamespaceListType = []NamespaceType

// NamespaceType Namespace object - formal name, EGF that governs namespace, VC/DIDAuth/etc.
type NamespaceType struct {
	CanonicalString string  `json:"canonicalString"`
	Description     *string `json:"description,omitempty"`

	// EgfURI URI of the EGF that defines the namespace.
	EgfURI     *string `json:"egfURI,omitempty"`
	Identifier string  `json:"identifier"`
}

// ProblemDetails A Problem Details object (RFC 7807)
type ProblemDetails struct {
	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail *string `json:"detail,omitempty"`

	// Instance An absolute URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code generated by the origin server for this occurrence of the problem.
	Status *int32 `json:"status,omitempty"`

	// Title A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
	Title *string `json:"title,omitempty"`

	// Type An absolute URI that identifies the problem type
	Type *string `json:"type,omitempty"`
}

// RegistryListType Array of RegistryQueryType
type RegistryListType = []RegistryType

// RegistryMetadataType defines model for RegistryMetadataType.
type RegistryMetadataType struct {
	// AdditionalEGFURIs List of URIs of Ecosystem Governance Frameworks that this Trust Registry operates under, in addition to the .primaryEGFURI
	AdditionalEGFURIs *[]Uri `json:"additionalEGFURIs,omitempty"`

	// Languages language codes (RFC 4646 - https://datatracker.ietf.org/doc/html/rfc4646)
	Languages              *[]string          `json:"languages,omitempty"`
	Lastupdated            time.Time          `json:"lastupdated"`
	ParticipatingNamepaces *NamespaceListType `json:"participatingNamepaces,omitempty"`

	// PrimaryEGFURI URI of the EGF that governs the Trust Registry.
	PrimaryEGFURI *string `json:"primaryEGFURI,omitempty"`
}

// RegistryType Data structure for basic Trust Registry indication of what the queried TR will state about another TR.
type RegistryType struct {
	// AdditionalEGFURIs List of URIs of Ecosystem Governance Frameworks that this Trust Registry operates under, in addition to the .primaryEGFURI
	AdditionalEGFURIs      *[]Uri             `json:"additionalEGFURIs,omitempty"`
	Description            *string            `json:"description,omitempty"`
	Identifier             string             `json:"identifier"`
	Name                   string             `json:"name"`
	ParticipatingNamepaces *NamespaceListType `json:"participatingNamepaces,omitempty"`

	// PeerType Relationship types - how does the TR that is being queried consider the other TR.
	//   * peer - registy is recognized as a peer under another jurisdiction or governance mechanism.
	//   * superior - registry is above this TR in a hierarchy.
	//   * subordinate - registry is subordinate to this TR in a hierarchy.
	//   * metaregistry - registry being queried is considered (by this TR) to be a metaregistry (aka registry of registries)
	PeerType *RegistryTypePeerType `json:"peerType,omitempty"`

	// PrimaryEGFURI URI of the EGF that governs the Trust Registry.
	PrimaryEGFURI *string `json:"primaryEGFURI,omitempty"`
}

// RegistryTypePeerType Relationship types - how does the TR that is being queried consider the other TR.
//   - peer - registy is recognized as a peer under another jurisdiction or governance mechanism.
//   - superior - registry is above this TR in a hierarchy.
//   - subordinate - registry is subordinate to this TR in a hierarchy.
//   - metaregistry - registry being queried is considered (by this TR) to be a metaregistry (aka registry of registries)
type RegistryTypePeerType string

// ResourceDirectType Resource that is served directly by this trust registry.
type ResourceDirectType struct {
	// Datatype TODO: DECIDE about mimeType vs. dataType as property name
	// The `kind` of resource (e.g. credential-definition, schema-definition, revocation-registry). intended
	// to be used by recipient for processing of the data payload.
	Datatype    string    `json:"datatype"`
	Identifier  string    `json:"identifier"`
	Lastupdated time.Time `json:"lastupdated"`

	// PayloadJSON JSON object
	PayloadJSON *map[string]interface{} `json:"payloadJSON,omitempty"`

	// ResourceURI string providing an URI formatted according to IETF RFC 3986.
	ResourceURI *Uri `json:"resourceURI,omitempty"`
}

// ResourceReferencedType Resource that is provided by reference to a different source.
type ResourceReferencedType struct {
	// Datatype TODO: DECIDE about mimeType vs. dataType as property name
	// The `kind` of resource (e.g. credential-definition, schema-definition, revocation-registry). intended
	// to be used by recipient for processing of the data payload.
	Datatype   string `json:"datatype"`
	Identifier string `json:"identifier"`

	// Integrity Integrity object
	Integrity   *IntegrityType `json:"integrity,omitempty"`
	Lastupdated time.Time      `json:"lastupdated"`

	// ResourceURI string providing an URI formatted according to IETF RFC 3986.
	ResourceURI Uri `json:"resourceURI"`
}

// StatusType Status and textual description for Entity Registration Status, and Entity Authorization Status
type StatusType struct {
	// Detail Optional free text that expands on the status parameter.
	Detail *string `json:"detail,omitempty"`

	// Status Provides a current status for entity at time of the query.
	// - current - status is current in the system of record.
	// - expired - status has expired in the system of record.
	// - terminated - entity has voluntarily terminated its status.
	// - revoked -  status was revoked by the governing authority.
	Status StatusTypeStatus `json:"status"`
}

// StatusTypeStatus Provides a current status for entity at time of the query.
// - current - status is current in the system of record.
// - expired - status has expired in the system of record.
// - terminated - entity has voluntarily terminated its status.
// - revoked -  status was revoked by the governing authority.
type StatusTypeStatus string

// TrustEstablishmentDocument Trust Establishment Document per https://identity.foundation/trust-establishment/
type TrustEstablishmentDocument struct {
	TBD string `json:"TBD"`
}

// Uri string providing an URI formatted according to IETF RFC 3986.
type Uri = string

// VID string providing an URI formatted according to IETF RFC 3986.
type VID = string

// VIDMethodListType defines model for VIDMethodListType.
type VIDMethodListType = []VIDMethodType

// VIDMethodType DID Method supported by the trust registry. May include the maximum
type VIDMethodType struct {
	// Identifier as "maintained" at https://w3c.github.io/did-spec-registries/#did-methods TODO: do better...
	Identifier string `json:"identifier"`

	// MaximumAssuranceLevel A DID Method may, due to technical or human trust considerations be limited in the assurance
	// level that it can provide.
	MaximumAssuranceLevel *AssuranceLevelType `json:"maximumAssuranceLevel,omitempty"`
}

// ValidityDatesType Date and Time of validity.
type ValidityDatesType struct {
	// ValidFromDT Indicates that the Identifier status applies at the indicated time. A time in the past indicates when the last status change was recorded in the Trust Registry.
	ValidFromDT *time.Time `json:"validFromDT,omitempty"`

	// ValidUntilDT Indicates the validity ends/ended at this date and time. A time in the past may indicate that the data have expired. A blank response indicates that the validity does not have an end value (i.e. does not or has not expired yet).
	ValidUntilDT *time.Time `json:"validUntilDT,omitempty"`
}

// BadRequest A Problem Details object (RFC 7807)
type BadRequest = ProblemDetails

// NotFound A Problem Details object (RFC 7807)
type NotFound = ProblemDetails

// Unauthorized A Problem Details object (RFC 7807)
type Unauthorized = ProblemDetails

// GetEntitiesEntityVIDAuthorizationParams defines parameters for GetEntitiesEntityVIDAuthorization.
type GetEntitiesEntityVIDAuthorizationParams struct {
	// AuthorizationVID The identifier of the Authorization that is being queried for this Entity.
	AuthorizationVID *Uri `form:"authorizationVID,omitempty" json:"authorizationVID,omitempty"`
}

// GetEntititiesEntityidParams defines parameters for GetEntititiesEntityid.
type GetEntititiesEntityidParams struct {
	// AuthorizationVID The identifier of the Authorization that is being queried for this Entity.
	AuthorizationVID *Uri `form:"authorizationVID,omitempty" json:"authorizationVID,omitempty"`
}

// GetLookupAssurancelevelsParams defines parameters for GetLookupAssurancelevels.
type GetLookupAssurancelevelsParams struct {
	// EgfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986.
	// Do **NOT** escape the URI.
	EgfURI Uri `form:"egfURI" json:"egfURI"`
}

// GetLookupAuthorizationsParams defines parameters for GetLookupAuthorizations.
type GetLookupAuthorizationsParams struct {
	// EgfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986.
	// Do **NOT** escape the URI.
	EgfURI Uri `form:"egfURI" json:"egfURI"`
}

// GetLookupVidmethodsParams defines parameters for GetLookupVidmethods.
type GetLookupVidmethodsParams struct {
	// EgfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level
	// that a DID Method is set at under the EGF.
	EgfURI Uri `form:"egfURI" json:"egfURI"`
}

// GetRegistriesRecognizedRegistriesParams defines parameters for GetRegistriesRecognizedRegistries.
type GetRegistriesRecognizedRegistriesParams struct {
	// NamespaceVID Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986.
	// Do **NOT** escape the URI.
	NamespaceVID *VID `form:"namespace-VID,omitempty" json:"namespace-VID,omitempty"`

	// EGFVID Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root.
	// The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986.
	// Do **NOT** escape the URI.
	EGFVID *VID `form:"EGF-VID,omitempty" json:"EGF-VID,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Determine whether an Entity has a particular Authorization.
	// (GET /entities/{entityVID}/authorization)
	GetEntitiesEntityVIDAuthorization(w http.ResponseWriter, r *http.Request, entityVID VID, params GetEntitiesEntityVIDAuthorizationParams)
	// Determine whether an Entity has a particular Authorization.
	// (GET /entities/{entityVID}/authorizations)
	GetEntitiesEntityVIDAuthorizations(w http.ResponseWriter, r *http.Request, entityVID VID)
	// Returns Registry Information about a particular entity that is represented in the queried system.
	// (GET /entitities/{entityid})
	GetEntititiesEntityid(w http.ResponseWriter, r *http.Request, entityid Uri, params GetEntititiesEntityidParams)
	// Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
	// (GET /lookup/assurancelevels)
	GetLookupAssurancelevels(w http.ResponseWriter, r *http.Request, params GetLookupAssurancelevelsParams)
	// Get a list of Rights that are used in this Trust Registry.
	// (GET /lookup/authorizations)
	GetLookupAuthorizations(w http.ResponseWriter, r *http.Request, params GetLookupAuthorizationsParams)
	// Get the namespaces that are supported in this trust Registry.
	// (GET /lookup/namespaces)
	GetLookupNamespaces(w http.ResponseWriter, r *http.Request)
	// Get a list of DID Methods that are supported by a particular Governance Framework.
	// (GET /lookup/vidmethods)
	GetLookupVidmethods(w http.ResponseWriter, r *http.Request, params GetLookupVidmethodsParams)
	// Provides metadata object.
	// (GET /metadata)
	GetMetadata(w http.ResponseWriter, r *http.Request)
	// Access a full data file that can be used offline.
	// (GET /offline/exportfile)
	GetOfflineFile(w http.ResponseWriter, r *http.Request)
	// Access a full data file that can be used offline.
	// (GET /offline/trustestablishmentdocument)
	GetTED(w http.ResponseWriter, r *http.Request)
	// Query this Trust Registry about its recognition of another Trust Registry.
	// (GET /registries/recognized-registries)
	GetRegistriesRecognizedRegistries(w http.ResponseWriter, r *http.Request, params GetRegistriesRecognizedRegistriesParams)
	// Get resource data indicated by DID.
	// (GET /registries/{registryVID}/)
	GetRegistriesRegistryVID(w http.ResponseWriter, r *http.Request, registryVID VID)
	// Query this Trust Registry about its recognition of a specific Trust Registry.
	// TODO: determine RoR (registry of registry) impacts here.
	// (GET /registries/{registryVID}/recognized-registries/)
	GetRegistriesRegistryVIDRecognizedRegistries(w http.ResponseWriter, r *http.Request, registryVID VID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Determine whether an Entity has a particular Authorization.
// (GET /entities/{entityVID}/authorization)
func (_ Unimplemented) GetEntitiesEntityVIDAuthorization(w http.ResponseWriter, r *http.Request, entityVID VID, params GetEntitiesEntityVIDAuthorizationParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Determine whether an Entity has a particular Authorization.
// (GET /entities/{entityVID}/authorizations)
func (_ Unimplemented) GetEntitiesEntityVIDAuthorizations(w http.ResponseWriter, r *http.Request, entityVID VID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns Registry Information about a particular entity that is represented in the queried system.
// (GET /entitities/{entityid})
func (_ Unimplemented) GetEntititiesEntityid(w http.ResponseWriter, r *http.Request, entityid Uri, params GetEntititiesEntityidParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
// (GET /lookup/assurancelevels)
func (_ Unimplemented) GetLookupAssurancelevels(w http.ResponseWriter, r *http.Request, params GetLookupAssurancelevelsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a list of Rights that are used in this Trust Registry.
// (GET /lookup/authorizations)
func (_ Unimplemented) GetLookupAuthorizations(w http.ResponseWriter, r *http.Request, params GetLookupAuthorizationsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the namespaces that are supported in this trust Registry.
// (GET /lookup/namespaces)
func (_ Unimplemented) GetLookupNamespaces(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a list of DID Methods that are supported by a particular Governance Framework.
// (GET /lookup/vidmethods)
func (_ Unimplemented) GetLookupVidmethods(w http.ResponseWriter, r *http.Request, params GetLookupVidmethodsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Provides metadata object.
// (GET /metadata)
func (_ Unimplemented) GetMetadata(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Access a full data file that can be used offline.
// (GET /offline/exportfile)
func (_ Unimplemented) GetOfflineFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Access a full data file that can be used offline.
// (GET /offline/trustestablishmentdocument)
func (_ Unimplemented) GetTED(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Query this Trust Registry about its recognition of another Trust Registry.
// (GET /registries/recognized-registries)
func (_ Unimplemented) GetRegistriesRecognizedRegistries(w http.ResponseWriter, r *http.Request, params GetRegistriesRecognizedRegistriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get resource data indicated by DID.
// (GET /registries/{registryVID}/)
func (_ Unimplemented) GetRegistriesRegistryVID(w http.ResponseWriter, r *http.Request, registryVID VID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Query this Trust Registry about its recognition of a specific Trust Registry.
// TODO: determine RoR (registry of registry) impacts here.
// (GET /registries/{registryVID}/recognized-registries/)
func (_ Unimplemented) GetRegistriesRegistryVIDRecognizedRegistries(w http.ResponseWriter, r *http.Request, registryVID VID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetEntitiesEntityVIDAuthorization operation middleware
func (siw *ServerInterfaceWrapper) GetEntitiesEntityVIDAuthorization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "entityVID" -------------
	var entityVID VID

	err = runtime.BindStyledParameterWithLocation("simple", false, "entityVID", runtime.ParamLocationPath, chi.URLParam(r, "entityVID"), &entityVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entityVID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntitiesEntityVIDAuthorizationParams

	// ------------- Optional query parameter "authorizationVID" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorizationVID", r.URL.Query(), &params.AuthorizationVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorizationVID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitiesEntityVIDAuthorization(w, r, entityVID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEntitiesEntityVIDAuthorizations operation middleware
func (siw *ServerInterfaceWrapper) GetEntitiesEntityVIDAuthorizations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "entityVID" -------------
	var entityVID VID

	err = runtime.BindStyledParameterWithLocation("simple", false, "entityVID", runtime.ParamLocationPath, chi.URLParam(r, "entityVID"), &entityVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entityVID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitiesEntityVIDAuthorizations(w, r, entityVID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEntititiesEntityid operation middleware
func (siw *ServerInterfaceWrapper) GetEntititiesEntityid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "entityid" -------------
	var entityid Uri

	err = runtime.BindStyledParameterWithLocation("simple", false, "entityid", runtime.ParamLocationPath, chi.URLParam(r, "entityid"), &entityid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entityid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntititiesEntityidParams

	// ------------- Optional query parameter "authorizationVID" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorizationVID", r.URL.Query(), &params.AuthorizationVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorizationVID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntititiesEntityid(w, r, entityid, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLookupAssurancelevels operation middleware
func (siw *ServerInterfaceWrapper) GetLookupAssurancelevels(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLookupAssurancelevelsParams

	// ------------- Required query parameter "egfURI" -------------

	if paramValue := r.URL.Query().Get("egfURI"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "egfURI"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "egfURI", r.URL.Query(), &params.EgfURI)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "egfURI", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLookupAssurancelevels(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLookupAuthorizations operation middleware
func (siw *ServerInterfaceWrapper) GetLookupAuthorizations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLookupAuthorizationsParams

	// ------------- Required query parameter "egfURI" -------------

	if paramValue := r.URL.Query().Get("egfURI"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "egfURI"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "egfURI", r.URL.Query(), &params.EgfURI)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "egfURI", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLookupAuthorizations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLookupNamespaces operation middleware
func (siw *ServerInterfaceWrapper) GetLookupNamespaces(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLookupNamespaces(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLookupVidmethods operation middleware
func (siw *ServerInterfaceWrapper) GetLookupVidmethods(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLookupVidmethodsParams

	// ------------- Required query parameter "egfURI" -------------

	if paramValue := r.URL.Query().Get("egfURI"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "egfURI"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "egfURI", r.URL.Query(), &params.EgfURI)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "egfURI", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLookupVidmethods(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetadata(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetOfflineFile operation middleware
func (siw *ServerInterfaceWrapper) GetOfflineFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOfflineFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTED operation middleware
func (siw *ServerInterfaceWrapper) GetTED(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTED(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRegistriesRecognizedRegistries operation middleware
func (siw *ServerInterfaceWrapper) GetRegistriesRecognizedRegistries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRegistriesRecognizedRegistriesParams

	// ------------- Optional query parameter "namespace-VID" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace-VID", r.URL.Query(), &params.NamespaceVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "namespace-VID", Err: err})
		return
	}

	// ------------- Optional query parameter "EGF-VID" -------------

	err = runtime.BindQueryParameter("form", true, false, "EGF-VID", r.URL.Query(), &params.EGFVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "EGF-VID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRegistriesRecognizedRegistries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRegistriesRegistryVID operation middleware
func (siw *ServerInterfaceWrapper) GetRegistriesRegistryVID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "registryVID" -------------
	var registryVID VID

	err = runtime.BindStyledParameterWithLocation("simple", false, "registryVID", runtime.ParamLocationPath, chi.URLParam(r, "registryVID"), &registryVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "registryVID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRegistriesRegistryVID(w, r, registryVID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRegistriesRegistryVIDRecognizedRegistries operation middleware
func (siw *ServerInterfaceWrapper) GetRegistriesRegistryVIDRecognizedRegistries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "registryVID" -------------
	var registryVID VID

	err = runtime.BindStyledParameterWithLocation("simple", false, "registryVID", runtime.ParamLocationPath, chi.URLParam(r, "registryVID"), &registryVID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "registryVID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRegistriesRegistryVIDRecognizedRegistries(w, r, registryVID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/entities/{entityVID}/authorization", wrapper.GetEntitiesEntityVIDAuthorization)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/entities/{entityVID}/authorizations", wrapper.GetEntitiesEntityVIDAuthorizations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/entitities/{entityid}", wrapper.GetEntititiesEntityid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/lookup/assurancelevels", wrapper.GetLookupAssurancelevels)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/lookup/authorizations", wrapper.GetLookupAuthorizations)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/lookup/namespaces", wrapper.GetLookupNamespaces)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/lookup/vidmethods", wrapper.GetLookupVidmethods)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/metadata", wrapper.GetMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/offline/exportfile", wrapper.GetOfflineFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/offline/trustestablishmentdocument", wrapper.GetTED)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/registries/recognized-registries", wrapper.GetRegistriesRecognizedRegistries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/registries/{registryVID}/", wrapper.GetRegistriesRegistryVID)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/registries/{registryVID}/recognized-registries/", wrapper.GetRegistriesRegistryVIDRecognizedRegistries)
	})

	return r
}
